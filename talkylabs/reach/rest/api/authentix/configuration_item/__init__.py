r"""
    This code was generated by
  ___ ___   _   ___ _  _    _____ _   _    _  ___   ___      _   ___ ___      ___   _   ___     ___ ___ _  _ ___ ___    _ _____ ___  ___ 
 | _ \ __| /_\ / __| || |__|_   _/_\ | |  | |/ | \ / / |    /_\ | _ ) __|___ / _ \ /_\ |_ _|__ / __| __| \| | __| _ \  /_\_   _/ _ \| _ \
 |   / _| / _ \ (__| __ |___|| |/ _ \| |__| ' < \ V /| |__ / _ \| _ \__ \___| (_) / _ \ | |___| (_ | _|| .` | _||   / / _ \| || (_) |   /
 |_|_\___/_/ \_\___|_||_|    |_/_/ \_\____|_|\_\ |_| |____/_/ \_\___/___/    \___/_/ \_\___|   \___|___|_|\_|___|_|_\/_/ \_\_| \___/|_|_\
 
    Reach Authentix API
     Reach Authentix API helps you easily integrate user authentification in your application. The authentification allows to verify that a user is indeed at the origin of a request from your application.  At the moment, the Reach Authentix API supports the following channels:    * SMS      * Email   We are continuously working to add additionnal channels. ## Base URL All endpoints described in this documentation are relative to the following base URL: ``` https://api.reach.talkylabs.com/rest/authentix/v1/ ```  The API is provided over HTTPS protocol to ensure data privacy.  ## API Authentication Requests made to the API must be authenticated. You need to provide the `ApiUser` and `ApiKey` associated with your applet. This information could be found in the settings of the applet. ```curl curl -X GET [BASE_URL]/configurations -H \"ApiUser:[Your_Api_User]\" -H \"ApiKey:[Your_Api_Key]\" ``` ## Reach Authentix API Workflow Three steps are needed in order to authenticate a given user using the Reach Authentix API. ### Step 1: Create an Authentix configuration A configuration is a set of settings used to define and send an authentication code to a user. This includes, for example: ```   - the length of the authentication code,    - the message template,    - and so on... ``` A configuaration could be created via the web application or directly using the Reach Authentix API. This step does not need to be performed every time one wants to use the Reach Authentix API. Indeed, once created, a configuartion could be used to authenticate several users in the future.    ### Step 2: Send an authentication code A configuration is used to send an authentication code via a selected channel to a user. For now, the supported channels are `sms`, and `email`. We are working hard to support additional channels. Newly created authentications will have a status of `awaiting`. ### Step 3: Verify the authentication code This step allows to verify that the code submitted by the user matched the one sent previously. If, there is a match, then the status of the authentication changes from `awaiting` to `passed`. Otherwise, the status remains `awaiting` until either it is verified or it expires. In the latter case, the status becomes `expired`. 

    NOTE: This class is auto generated by OpenAPI Generator.
    https://openapi-generator.tech
    Do not edit the class manually.
"""


from datetime import date, datetime
from decimal import Decimal
from typing import Any, Dict, List, Optional, Union, Iterator, AsyncIterator
from talkylabs.reach.base import deserialize, serialize, values
from talkylabs.reach.base.instance_context import InstanceContext
from talkylabs.reach.base.instance_resource import InstanceResource
from talkylabs.reach.base.list_resource import ListResource
from talkylabs.reach.base.version import Version
from talkylabs.reach.base.page import Page
from talkylabs.reach.rest.api.authentix.configuration_item.authentication_control_item import AuthenticationControlItemList
from talkylabs.reach.rest.api.authentix.configuration_item.authentication_item import AuthenticationItemList


class ConfigurationItemInstance(InstanceResource):

    """
    :ivar appletId: The identifier of the applet creating the configuration.
    :ivar apiVersion: The API version used to create the configuration.
    :ivar configurationId: The identifier of the configuration.
    :ivar serviceName: The name of the authentication service.
    :ivar codeLength: The length of the code to be generated.
    :ivar allowCustomCode: A flag indicating if the configuration allows sending custom and non-generated code.
    :ivar usedForDigitalPayment: A flag indicating if the configuration is used to authenticate digital payments.
    :ivar defaultExpiryTime: the default expiry time of the authentication code.
    :ivar defaultMaxTrials: the default maximum number of trials per authentication.
    :ivar defaultMaxControls: the default maximum number of code controls per authentication.
    :ivar smtpSettingId: The ID of the SMTP settings used by the configuration.
    :ivar emailTemplateId: The default email template ID used by this configuration. 
    :ivar smsTemplateId: The default sms template ID used by this configuration. 
    :ivar dateCreated: The date and time in GMT that the configuration was created. 
    :ivar dateUpdated: The date and time in GMT that the configuration was last updated. 
    """

    def __init__(self, version: Version, payload: Dict[str, Any], configuration_id: Optional[str] = None):
        super().__init__(version)

        
        self.appletId: Optional[str] = payload.get("appletId")
        self.apiVersion: Optional[str] = payload.get("apiVersion")
        self.configurationId: Optional[str] = payload.get("configurationId")
        self.serviceName: Optional[str] = payload.get("serviceName")
        self.codeLength: Optional[int] = deserialize.integer(payload.get("codeLength"))
        self.allowCustomCode: Optional[bool] = payload.get("allowCustomCode")
        self.usedForDigitalPayment: Optional[bool] = payload.get("usedForDigitalPayment")
        self.defaultExpiryTime: Optional[int] = deserialize.integer(payload.get("defaultExpiryTime"))
        self.defaultMaxTrials: Optional[int] = deserialize.integer(payload.get("defaultMaxTrials"))
        self.defaultMaxControls: Optional[int] = deserialize.integer(payload.get("defaultMaxControls"))
        self.smtpSettingId: Optional[str] = payload.get("smtpSettingId")
        self.emailTemplateId: Optional[str] = payload.get("emailTemplateId")
        self.smsTemplateId: Optional[str] = payload.get("smsTemplateId")
        self.dateCreated: Optional[datetime] = deserialize.iso8601_datetime(payload.get("dateCreated"))
        self.dateUpdated: Optional[datetime] = deserialize.iso8601_datetime(payload.get("dateUpdated"))

        
        self._solution = { 
            "configuration_id": configuration_id or self.configurationId,
        }
        self._context: Optional[ConfigurationItemContext] = None

    @property
    def _proxy(self) -> "ConfigurationItemContext":
        """
        Generate an instance context for the instance, the context is capable of
        performing various actions. All instance actions are proxied to the context

        :returns: ConfigurationItemContext for this ConfigurationItemInstance
        """
        if self._context is None:
            self._context = ConfigurationItemContext(self._version, configuration_id=self._solution['configuration_id'],)
        return self._context
    
    
    def delete(self) -> bool:
        """
        Deletes the ConfigurationItemInstance
        

        :returns: True if delete succeeds, False otherwise
        """
        return self._proxy.delete()
    async def delete_async(self) -> bool:
        """
        Asynchronous coroutine that deletes the ConfigurationItemInstance
        

        :returns: True if delete succeeds, False otherwise
        """
        return await self._proxy.delete_async()
    
    
    def fetch(self) -> "ConfigurationItemInstance":
        """
        Fetch the ConfigurationItemInstance
        

        :returns: The fetched ConfigurationItemInstance
        """
        return self._proxy.fetch()

    async def fetch_async(self) -> "ConfigurationItemInstance":
        """
        Asynchronous coroutine to fetch the ConfigurationItemInstance
        

        :returns: The fetched ConfigurationItemInstance
        """
        return await self._proxy.fetch_async()
    
    
    def update(self, service_name: Union[str, object]=values.unset, code_length: Union[int, object]=values.unset, allow_custom_code: Union[bool, object]=values.unset, used_for_digital_payment: Union[bool, object]=values.unset, default_expiry_time: Union[int, object]=values.unset, default_max_trials: Union[int, object]=values.unset, default_max_controls: Union[int, object]=values.unset, smtp_setting_id: Union[str, object]=values.unset, email_template_id: Union[str, object]=values.unset, sms_template_id: Union[str, object]=values.unset) -> "ConfigurationItemInstance":
        """
        Update the ConfigurationItemInstance
        
        :param service_name: The name of the authentication service attached to this configuration. It can be up to 40 characters long.
        :param code_length: The length of the code to be generated. It must be a value between 4 and 10, inclusive.
        :param allow_custom_code: A flag indicating if the configuration should allow sending custom and non-generated code.
        :param used_for_digital_payment: A flag indicating if the configuration is used to authenticate digital payments. In such a case, additional information such as the amount and the payee of the financial transaction should be sent to when starting the authentication.
        :param default_expiry_time: It represents how long, in minutes, an authentication process will remained in the `awaiting` status before moving to `expired` in the case no valid matching is performed in between. It must be any value between 1 and 1440 which represents 24 hours.
        :param default_max_trials: It represents the maximum number of trials per authentication. 
        :param default_max_controls: It represents the maximum number of code controls per authentication. It must be between 1 and 6 inclusive. 
        :param smtp_setting_id: This is the ID of the SMTP settings used by this configuration. It is mandatory for sending authentication codes via email.
        :param email_template_id: This is the ID of the default email template to use for sending authenetication codes via email. 
        :param sms_template_id: This is the ID of the default sms template to use for sending authenetication codes via sms. 

        :returns: The updated ConfigurationItemInstance
        """
        return self._proxy.update(service_name=service_name, code_length=code_length, allow_custom_code=allow_custom_code, used_for_digital_payment=used_for_digital_payment, default_expiry_time=default_expiry_time, default_max_trials=default_max_trials, default_max_controls=default_max_controls, smtp_setting_id=smtp_setting_id, email_template_id=email_template_id, sms_template_id=sms_template_id, )

    async def update_async(self, service_name: Union[str, object]=values.unset, code_length: Union[int, object]=values.unset, allow_custom_code: Union[bool, object]=values.unset, used_for_digital_payment: Union[bool, object]=values.unset, default_expiry_time: Union[int, object]=values.unset, default_max_trials: Union[int, object]=values.unset, default_max_controls: Union[int, object]=values.unset, smtp_setting_id: Union[str, object]=values.unset, email_template_id: Union[str, object]=values.unset, sms_template_id: Union[str, object]=values.unset) -> "ConfigurationItemInstance":
        """
        Asynchronous coroutine to update the ConfigurationItemInstance
        
        :param service_name: The name of the authentication service attached to this configuration. It can be up to 40 characters long.
        :param code_length: The length of the code to be generated. It must be a value between 4 and 10, inclusive.
        :param allow_custom_code: A flag indicating if the configuration should allow sending custom and non-generated code.
        :param used_for_digital_payment: A flag indicating if the configuration is used to authenticate digital payments. In such a case, additional information such as the amount and the payee of the financial transaction should be sent to when starting the authentication.
        :param default_expiry_time: It represents how long, in minutes, an authentication process will remained in the `awaiting` status before moving to `expired` in the case no valid matching is performed in between. It must be any value between 1 and 1440 which represents 24 hours.
        :param default_max_trials: It represents the maximum number of trials per authentication. 
        :param default_max_controls: It represents the maximum number of code controls per authentication. It must be between 1 and 6 inclusive. 
        :param smtp_setting_id: This is the ID of the SMTP settings used by this configuration. It is mandatory for sending authentication codes via email.
        :param email_template_id: This is the ID of the default email template to use for sending authenetication codes via email. 
        :param sms_template_id: This is the ID of the default sms template to use for sending authenetication codes via sms. 

        :returns: The updated ConfigurationItemInstance
        """
        return await self._proxy.update_async(service_name=service_name, code_length=code_length, allow_custom_code=allow_custom_code, used_for_digital_payment=used_for_digital_payment, default_expiry_time=default_expiry_time, default_max_trials=default_max_trials, default_max_controls=default_max_controls, smtp_setting_id=smtp_setting_id, email_template_id=email_template_id, sms_template_id=sms_template_id, )
    
    @property
    def authentication_control_items(self) -> AuthenticationControlItemList:
        """
        Access the authentication_control_items
        """
        return self._proxy.authentication_control_items
    
    @property
    def authentication_items(self) -> AuthenticationItemList:
        """
        Access the authentication_items
        """
        return self._proxy.authentication_items
    
    def __repr__(self) -> str:
        """
        Provide a friendly representation

        :returns: Machine friendly representation
        """
        context = ' '.join('{}={}'.format(k, v) for k, v in self._solution.items())
        return '<Reach.Api.Authentix.ConfigurationItemInstance {}>'.format(context)

    def __str__(self) -> str:
        """
        Provide a str representation

        :returns: str representation
        """
        repr = { 
            'appletId': self.appletId,
            'apiVersion': self.apiVersion,
            'configurationId': self.configurationId,
            'serviceName': self.serviceName,
            'codeLength': self.codeLength,
            'allowCustomCode': self.allowCustomCode,
            'usedForDigitalPayment': self.usedForDigitalPayment,
            'defaultExpiryTime': self.defaultExpiryTime,
            'defaultMaxTrials': self.defaultMaxTrials,
            'defaultMaxControls': self.defaultMaxControls,
            'smtpSettingId': self.smtpSettingId,
            'emailTemplateId': self.emailTemplateId,
            'smsTemplateId': self.smsTemplateId,
            'dateCreated': self.dateCreated,
            'dateUpdated': self.dateUpdated,
        }
        return serialize.serialize(repr)

class ConfigurationItemContext(InstanceContext):

    def __init__(self, version: Version, configuration_id: str):
        """
        Initialize the ConfigurationItemContext

        :param version: Version that contains the resource
        :param configuration_id: The identifier of the configuration to be updated.
        """
        super().__init__(version)

        
        # Path Solution
        self._solution = { 
            'configuration_id': configuration_id,
        }
        
        
        self._uri = '/authentix/v1/configurations/{configuration_id}'.format(**self._solution)
        
        
        self._authentication_control_items: Optional[AuthenticationControlItemList] = None
        self._authentication_items: Optional[AuthenticationItemList] = None
    
    
    def delete(self) -> bool:
        """
        Deletes the ConfigurationItemInstance

        
        :returns: True if delete succeeds, False otherwise
        """
        return self._version.delete(method='DELETE', uri=self._uri,)

    async def delete_async(self) -> bool:
        """
        Asynchronous coroutine that deletes the ConfigurationItemInstance

        
        :returns: True if delete succeeds, False otherwise
        """
        return await self._version.delete_async(method='DELETE', uri=self._uri,)
    
    
    def fetch(self) -> ConfigurationItemInstance:
        """
        Fetch the ConfigurationItemInstance
        

        :returns: The fetched ConfigurationItemInstance
        """
        
        payload = self._version.fetch(method='GET', uri=self._uri, )

        return ConfigurationItemInstance(
            self._version,
            payload,
            configuration_id=self._solution['configuration_id'],
            
        )

    async def fetch_async(self) -> ConfigurationItemInstance:
        """
        Asynchronous coroutine to fetch the ConfigurationItemInstance
        

        :returns: The fetched ConfigurationItemInstance
        """
        
        payload = await self._version.fetch_async(method='GET', uri=self._uri, )

        return ConfigurationItemInstance(
            self._version,
            payload,
            configuration_id=self._solution['configuration_id'],
            
        )
    
    
    def update(self, service_name: Union[str, object]=values.unset, code_length: Union[int, object]=values.unset, allow_custom_code: Union[bool, object]=values.unset, used_for_digital_payment: Union[bool, object]=values.unset, default_expiry_time: Union[int, object]=values.unset, default_max_trials: Union[int, object]=values.unset, default_max_controls: Union[int, object]=values.unset, smtp_setting_id: Union[str, object]=values.unset, email_template_id: Union[str, object]=values.unset, sms_template_id: Union[str, object]=values.unset) -> ConfigurationItemInstance:
        """
        Update the ConfigurationItemInstance
        
        :param service_name: The name of the authentication service attached to this configuration. It can be up to 40 characters long.
        :param code_length: The length of the code to be generated. It must be a value between 4 and 10, inclusive.
        :param allow_custom_code: A flag indicating if the configuration should allow sending custom and non-generated code.
        :param used_for_digital_payment: A flag indicating if the configuration is used to authenticate digital payments. In such a case, additional information such as the amount and the payee of the financial transaction should be sent to when starting the authentication.
        :param default_expiry_time: It represents how long, in minutes, an authentication process will remained in the `awaiting` status before moving to `expired` in the case no valid matching is performed in between. It must be any value between 1 and 1440 which represents 24 hours.
        :param default_max_trials: It represents the maximum number of trials per authentication. 
        :param default_max_controls: It represents the maximum number of code controls per authentication. It must be between 1 and 6 inclusive. 
        :param smtp_setting_id: This is the ID of the SMTP settings used by this configuration. It is mandatory for sending authentication codes via email.
        :param email_template_id: This is the ID of the default email template to use for sending authenetication codes via email. 
        :param sms_template_id: This is the ID of the default sms template to use for sending authenetication codes via sms. 

        :returns: The updated ConfigurationItemInstance
        """
        data = values.of({ 
            'serviceName': service_name,
            'codeLength': code_length,
            'allowCustomCode': allow_custom_code,
            'usedForDigitalPayment': used_for_digital_payment,
            'defaultExpiryTime': default_expiry_time,
            'defaultMaxTrials': default_max_trials,
            'defaultMaxControls': default_max_controls,
            'smtpSettingId': smtp_setting_id,
            'emailTemplateId': email_template_id,
            'smsTemplateId': sms_template_id,
        })
        

        payload = self._version.update(method='POST', uri=self._uri, data=data,)

        return ConfigurationItemInstance(
            self._version,
            payload,
            configuration_id=self._solution['configuration_id']
        )

    async def update_async(self, service_name: Union[str, object]=values.unset, code_length: Union[int, object]=values.unset, allow_custom_code: Union[bool, object]=values.unset, used_for_digital_payment: Union[bool, object]=values.unset, default_expiry_time: Union[int, object]=values.unset, default_max_trials: Union[int, object]=values.unset, default_max_controls: Union[int, object]=values.unset, smtp_setting_id: Union[str, object]=values.unset, email_template_id: Union[str, object]=values.unset, sms_template_id: Union[str, object]=values.unset) -> ConfigurationItemInstance:
        """
        Asynchronous coroutine to update the ConfigurationItemInstance
        
        :param service_name: The name of the authentication service attached to this configuration. It can be up to 40 characters long.
        :param code_length: The length of the code to be generated. It must be a value between 4 and 10, inclusive.
        :param allow_custom_code: A flag indicating if the configuration should allow sending custom and non-generated code.
        :param used_for_digital_payment: A flag indicating if the configuration is used to authenticate digital payments. In such a case, additional information such as the amount and the payee of the financial transaction should be sent to when starting the authentication.
        :param default_expiry_time: It represents how long, in minutes, an authentication process will remained in the `awaiting` status before moving to `expired` in the case no valid matching is performed in between. It must be any value between 1 and 1440 which represents 24 hours.
        :param default_max_trials: It represents the maximum number of trials per authentication. 
        :param default_max_controls: It represents the maximum number of code controls per authentication. It must be between 1 and 6 inclusive. 
        :param smtp_setting_id: This is the ID of the SMTP settings used by this configuration. It is mandatory for sending authentication codes via email.
        :param email_template_id: This is the ID of the default email template to use for sending authenetication codes via email. 
        :param sms_template_id: This is the ID of the default sms template to use for sending authenetication codes via sms. 

        :returns: The updated ConfigurationItemInstance
        """
        data = values.of({ 
            'serviceName': service_name,
            'codeLength': code_length,
            'allowCustomCode': allow_custom_code,
            'usedForDigitalPayment': used_for_digital_payment,
            'defaultExpiryTime': default_expiry_time,
            'defaultMaxTrials': default_max_trials,
            'defaultMaxControls': default_max_controls,
            'smtpSettingId': smtp_setting_id,
            'emailTemplateId': email_template_id,
            'smsTemplateId': sms_template_id,
        })
        

        payload = await self._version.update_async(method='POST', uri=self._uri, data=data,)

        return ConfigurationItemInstance(
            self._version,
            payload,
            configuration_id=self._solution['configuration_id']
        )
    
    
    @property
    def authentication_control_items(self) -> AuthenticationControlItemList:
        """
        Access the authentication_control_items
        """
        if self._authentication_control_items is None:
            self._authentication_control_items = AuthenticationControlItemList(
                self._version, 
                self._solution['configuration_id'],
            )
        return self._authentication_control_items
    
    @property
    def authentication_items(self) -> AuthenticationItemList:
        """
        Access the authentication_items
        """
        if self._authentication_items is None:
            self._authentication_items = AuthenticationItemList(
                self._version, 
                self._solution['configuration_id'],
            )
        return self._authentication_items
    
    def __repr__(self) -> str:
        """
        Provide a friendly representation

        :returns: Machine friendly representation
        """
        context = ' '.join('{}={}'.format(k, v) for k, v in self._solution.items())
        return '<Reach.Api.Authentix.ConfigurationItemContext {}>'.format(context)











class ConfigurationItemPage(Page):

    def get_instance(self, payload: Dict[str, Any]) -> ConfigurationItemInstance:
        """
        Build an instance of ConfigurationItemInstance

        :param payload: Payload response from the API
        """
        return ConfigurationItemInstance(self._version, payload)

    def __repr__(self) -> str:
        """
        Provide a friendly representation

        :returns: Machine friendly representation
        """
        return "<Reach.Api.Authentix.ConfigurationItemPage>"





class ConfigurationItemList(ListResource):

    def __init__(self, version: Version):
        """
        Initialize the ConfigurationItemList

        :param version: Version that contains the resource
        
        """
        super().__init__(version)

        
        
        self._uri = '/authentix/v1/configurations'
        
        
        
    
    
    
    
    def create(self, service_name: str, code_length: Union[int, object]=values.unset, allow_custom_code: Union[bool, object]=values.unset, used_for_digital_payment: Union[bool, object]=values.unset, default_expiry_time: Union[int, object]=values.unset, default_max_trials: Union[int, object]=values.unset, default_max_controls: Union[int, object]=values.unset, smtp_setting_id: Union[str, object]=values.unset, email_template_id: Union[str, object]=values.unset, sms_template_id: Union[str, object]=values.unset) -> ConfigurationItemInstance:
        """
        Create the ConfigurationItemInstance

        :param service_name: The name of the authentication service attached to this configuration. It can be up to 40 characters long.
        :param code_length: The length of the code to be generated. It must be a value between 4 and 10, inclusive. If not specified, the default value is 5.
        :param allow_custom_code: A flag indicating if the configuration should allow sending custom and non-generated code.
        :param used_for_digital_payment: A flag indicating if the configuration is used to authenticate digital payments. In such a case, additional information such as the amount and the payee of the financial transaction should be sent to when starting the authentication.
        :param default_expiry_time: It represents how long, in minutes, an authentication process will remained in the `awaiting` status before moving to `expired` in the case no valid matching is performed in between.   It also means that the code sent for the autentication remains the same during its validity period until the autentication is successful. In other words, if another authentication request is asked within that period, the same code will be sent.  If not specified, the default value is 15 minutes. It must be any value between 1 and 1440 which represents 24 hours. 
        :param default_max_trials: It represents the maximum number of trials per authentication. The default value is 5. 
        :param default_max_controls: It represents the maximum number of code controls per authentication. It must be between 1 and 6 inclusive. The default value is 3. 
        :param smtp_setting_id: This is the ID of the SMTP settings used by this configuration. It is mandatory to provide this parameter in order to send the authentication code via email. An SMTPSetting can be created via the web application in an easy way.
        :param email_template_id: This is the ID of the default email template to use for sending authenetication codes via email. If not provided, the message used will be:   ```    ${SERVICE_NAME}: your authentication code is ${CODE}.  ```   
        :param sms_template_id: This is the ID of the default sms template to use for sending authenetication codes via sms. If not provided, the message used will be:   ```    ${SERVICE_NAME}: your authentication code is ${CODE}.  ``` 
        
        :returns: The created ConfigurationItemInstance
        """
        data = values.of({ 
            'serviceName': service_name,
            'codeLength': code_length,
            'allowCustomCode': allow_custom_code,
            'usedForDigitalPayment': used_for_digital_payment,
            'defaultExpiryTime': default_expiry_time,
            'defaultMaxTrials': default_max_trials,
            'defaultMaxControls': default_max_controls,
            'smtpSettingId': smtp_setting_id,
            'emailTemplateId': email_template_id,
            'smsTemplateId': sms_template_id,
        })
        
        payload = self._version.create(method='POST', uri=self._uri, data=data,)

        return ConfigurationItemInstance(self._version, payload)

    async def create_async(self, service_name: str, code_length: Union[int, object]=values.unset, allow_custom_code: Union[bool, object]=values.unset, used_for_digital_payment: Union[bool, object]=values.unset, default_expiry_time: Union[int, object]=values.unset, default_max_trials: Union[int, object]=values.unset, default_max_controls: Union[int, object]=values.unset, smtp_setting_id: Union[str, object]=values.unset, email_template_id: Union[str, object]=values.unset, sms_template_id: Union[str, object]=values.unset) -> ConfigurationItemInstance:
        """
        Asynchronously create the ConfigurationItemInstance

        :param service_name: The name of the authentication service attached to this configuration. It can be up to 40 characters long.
        :param code_length: The length of the code to be generated. It must be a value between 4 and 10, inclusive. If not specified, the default value is 5.
        :param allow_custom_code: A flag indicating if the configuration should allow sending custom and non-generated code.
        :param used_for_digital_payment: A flag indicating if the configuration is used to authenticate digital payments. In such a case, additional information such as the amount and the payee of the financial transaction should be sent to when starting the authentication.
        :param default_expiry_time: It represents how long, in minutes, an authentication process will remained in the `awaiting` status before moving to `expired` in the case no valid matching is performed in between.   It also means that the code sent for the autentication remains the same during its validity period until the autentication is successful. In other words, if another authentication request is asked within that period, the same code will be sent.  If not specified, the default value is 15 minutes. It must be any value between 1 and 1440 which represents 24 hours. 
        :param default_max_trials: It represents the maximum number of trials per authentication. The default value is 5. 
        :param default_max_controls: It represents the maximum number of code controls per authentication. It must be between 1 and 6 inclusive. The default value is 3. 
        :param smtp_setting_id: This is the ID of the SMTP settings used by this configuration. It is mandatory to provide this parameter in order to send the authentication code via email. An SMTPSetting can be created via the web application in an easy way.
        :param email_template_id: This is the ID of the default email template to use for sending authenetication codes via email. If not provided, the message used will be:   ```    ${SERVICE_NAME}: your authentication code is ${CODE}.  ```   
        :param sms_template_id: This is the ID of the default sms template to use for sending authenetication codes via sms. If not provided, the message used will be:   ```    ${SERVICE_NAME}: your authentication code is ${CODE}.  ``` 
        
        :returns: The created ConfigurationItemInstance
        """
        data = values.of({ 
            'serviceName': service_name,
            'codeLength': code_length,
            'allowCustomCode': allow_custom_code,
            'usedForDigitalPayment': used_for_digital_payment,
            'defaultExpiryTime': default_expiry_time,
            'defaultMaxTrials': default_max_trials,
            'defaultMaxControls': default_max_controls,
            'smtpSettingId': smtp_setting_id,
            'emailTemplateId': email_template_id,
            'smsTemplateId': sms_template_id,
        })
        
        payload = await self._version.create_async(method='POST', uri=self._uri, data=data,)

        return ConfigurationItemInstance(self._version, payload)
    
    
    def stream(self, 
        
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> Iterator[ConfigurationItemInstance]:
        """
        Streams ConfigurationItemInstance records from the API as a generator stream.
        This operation lazily loads records as efficiently as possible until the limit
        is reached.
        The results are returned as a generator, so this operation is memory efficient.
        
        :param limit: Upper limit for the number of records to return. stream()
                      guarantees to never return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, stream() will attempt to read the
                          limit with the most efficient page size, i.e. min(limit, 1000)

        :returns: Generator that will yield up to limit results
        """
        limits = self._version.read_limits(limit, page_size)
        page = self.page(
            page_size=limits['page_size']
        )

        return self._version.stream(page, limits['limit'])

    async def stream_async(self, 
        
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> AsyncIterator[ConfigurationItemInstance]:
        """
        Asynchronously streams ConfigurationItemInstance records from the API as a generator stream.
        This operation lazily loads records as efficiently as possible until the limit
        is reached.
        The results are returned as a generator, so this operation is memory efficient.
        
        :param limit: Upper limit for the number of records to return. stream()
                      guarantees to never return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, stream() will attempt to read the
                          limit with the most efficient page size, i.e. min(limit, 1000)

        :returns: Generator that will yield up to limit results
        """
        limits = self._version.read_limits(limit, page_size)
        page = await self.page_async(
            page_size=limits['page_size']
        )

        return self._version.stream_async(page, limits['limit'])

    def list(self, 
        
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> List[ConfigurationItemInstance]:
        """
        Lists ConfigurationItemInstance records from the API as a list.
        Unlike stream(), this operation is eager and will load `limit` records into
        memory before returning.
        
        :param limit: Upper limit for the number of records to return. list() guarantees
                      never to return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, list() will attempt to read the limit
                          with the most efficient page size, i.e. min(limit, 1000)

        :returns: list that will contain up to limit results
        """
        return list(self.stream(
            limit=limit,
            page_size=page_size,
        ))

    async def list_async(self, 
        
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> List[ConfigurationItemInstance]:
        """
        Asynchronously lists ConfigurationItemInstance records from the API as a list.
        Unlike stream(), this operation is eager and will load `limit` records into
        memory before returning.
        
        :param limit: Upper limit for the number of records to return. list() guarantees
                      never to return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, list() will attempt to read the limit
                          with the most efficient page size, i.e. min(limit, 1000)

        :returns: list that will contain up to limit results
        """
        return [record async for record in await self.stream_async(
            limit=limit,
            page_size=page_size,
        )]

    def page(self, 
        
        page_number: Union[int, object] = values.unset,
        page_size: Union[int, object] = values.unset,
    ) -> ConfigurationItemPage:
        """
        Retrieve a single page of ConfigurationItemInstance records from the API.
        Request is executed immediately
        
        :param page_number: Page Number, this value is simply for client state
        :param page_size: Number of records to return, defaults to 20

        :returns: Page of ConfigurationItemInstance
        """
        data = values.of({ 
            'page': page_number,
            'pageSize': page_size,
        })

        baseUrl = self._version.absolute_url(uri=self._uri)
        baseUrl = self._version.url_without_pagination_info(baseUrl, params=data)
        response = self._version.page(method='GET', uri=self._uri, params=data)
        return ConfigurationItemPage(baseUrl, self._version, response)

    async def page_async(self, 
        
        page_number: Union[int, object] = values.unset,
        page_size: Union[int, object] = values.unset,
    ) -> ConfigurationItemPage:
        """
        Asynchronously retrieve a single page of ConfigurationItemInstance records from the API.
        Request is executed immediately
        
        :param page_number: Page Number, this value is simply for client state
        :param page_size: Number of records to return, defaults to 20

        :returns: Page of ConfigurationItemInstance
        """
        data = values.of({ 
            'page': page_number,
            'pageSize': page_size,
        })

        baseUrl = self._version.absolute_url(uri=self._uri)
        baseUrl = self._version.url_without_pagination_info(baseUrl, params=data)
        response = await self._version.page_async(method='GET', uri=self._uri, params=data)
        return ConfigurationItemPage(baseUrl, self._version, response)

    def get_page(self, target_url: str) -> ConfigurationItemPage:
        """
        Retrieve a specific page of ConfigurationItemInstance records from the API.
        Request is executed immediately

        :param target_url: API-generated URL for the requested results page

        :returns: Page of ConfigurationItemInstance
        """
        baseUrl = self._version.url_without_pagination_info(target_url)
        response = self._version.domain.reach.request(
            'GET',
            target_url
        )
        return ConfigurationItemPage(baseUrl, self._version, response)

    async def get_page_async(self, target_url: str) -> ConfigurationItemPage:
        """
        Asynchronously retrieve a specific page of ConfigurationItemInstance records from the API.
        Request is executed immediately

        :param target_url: API-generated URL for the requested results page

        :returns: Page of ConfigurationItemInstance
        """
        baseUrl = self._version.url_without_pagination_info(target_url)
        response = await self._version.domain.reach.request_async(
            'GET',
            target_url
        )
        return ConfigurationItemPage(baseUrl, self._version, response)







    def get(self, configuration_id: str) -> ConfigurationItemContext:
        """
        Constructs a ConfigurationItemContext
        
        :param configuration_id: The identifier of the configuration to be updated.
        """
        return ConfigurationItemContext(self._version, configuration_id=configuration_id)

    def __call__(self, configuration_id: str) -> ConfigurationItemContext:
        """
        Constructs a ConfigurationItemContext
        
        :param configuration_id: The identifier of the configuration to be updated.
        """
        return ConfigurationItemContext(self._version, configuration_id=configuration_id)

    def __repr__(self) -> str:
        """
        Provide a friendly representation

        :returns: Machine friendly representation
        """
        return '<Reach.Api.Authentix.ConfigurationItemList>'

