r"""
    This code was generated by
  ___ ___   _   ___ _  _    _____ _   _    _  ___   ___      _   ___ ___      ___   _   ___     ___ ___ _  _ ___ ___    _ _____ ___  ___ 
 | _ \ __| /_\ / __| || |__|_   _/_\ | |  | |/ | \ / / |    /_\ | _ ) __|___ / _ \ /_\ |_ _|__ / __| __| \| | __| _ \  /_\_   _/ _ \| _ \
 |   / _| / _ \ (__| __ |___|| |/ _ \| |__| ' < \ V /| |__ / _ \| _ \__ \___| (_) / _ \ | |___| (_ | _|| .` | _||   / / _ \| || (_) |   /
 |_|_\___/_/ \_\___|_||_|    |_/_/ \_\____|_|\_\ |_| |____/_/ \_\___/___/    \___/_/ \_\___|   \___|___|_|\_|___|_|_\/_/ \_\_| \___/|_|_\
 
    Reach Messaging API
    Reach SMS API helps you add robust messaging capabilities to your applications.  Using this REST API, you can * send SMS messages * track the delivery of sent messages * schedule SMS messages to send at a later time * retrieve and modify message history

    NOTE: This class is auto generated by OpenAPI Generator.
    https://openapi-generator.tech
    Do not edit the class manually.
"""


from datetime import date, datetime
from decimal import Decimal
from typing import Any, Dict, List, Optional, Union, Iterator, AsyncIterator
from talkylabs.reach.base import deserialize, serialize, values
from talkylabs.reach.base.instance_context import InstanceContext
from talkylabs.reach.base.instance_resource import InstanceResource
from talkylabs.reach.base.list_resource import ListResource
from talkylabs.reach.base.version import Version
from talkylabs.reach.base.page import Page


class MessagingItemInstance(InstanceResource):

    """
    :ivar appletId: The identifier of the applet sending the message.
    :ivar apiVersion: The API version used to process the message.
    :ivar body: The message text.
    :ivar dest: The phone number in E.164 format that received the message.
    :ivar src: The phone number (in E.164 format), or the alphanumeric sender ID that initiated the message.
    :ivar bulkId: The bulk identifier allowing to group messages together and have corresponding statistics.
    :ivar numSegments: The number of segments associated to the message. A message body that is too large to be sent in a single SMS is segmented and charged as multiple messages. The segments are reassembled once received by the destination phone. A message can have a maximum of 10 segments. 
    :ivar numMedia: The number of media files included in the message
    :ivar price: The cost billed for the message, in the currency specified by `priceUnit`.
    :ivar priceUnit: The currency, in ISO 4127 format, in which price is measured. for example, usd, xaf, eur, cad.
    :ivar messageId: The identifier of the message
    :ivar status: The status of the message. Can be: `sent`, `scheduled`, `failed`, `delivered`, `undelivered`, `canceled`, `accepted`, `queued`, `sending`, `received`, `receiving`.  
    :ivar messageType: The type of the message. Can be: `inbound` for incoming messages, `outbound` for messages initiated by a REST API. 
    :ivar errorCode: The error code returned if the message status is `failed` or `undelivered`. The errorMessage provides more information about the failure. The value is null if the message is successful. 
    :ivar errorMessage: The error message returned if the message status is `failed` or `undelivered`.  The value is null if the message is successful. 
    :ivar dateCreated: The date and time in GMT that the message was created. 
    :ivar dateSent: The date and time in GMT that the message was sent. 
    :ivar dateUpdated: The date and time in GMT that the message status was last updated. 
    """

    def __init__(self, version: Version, payload: Dict[str, Any]):
        super().__init__(version)

        
        self.appletId: Optional[str] = payload.get("appletId")
        self.apiVersion: Optional[str] = payload.get("apiVersion")
        self.body: Optional[str] = payload.get("body")
        self.dest: Optional[str] = payload.get("dest")
        self.src: Optional[str] = payload.get("src")
        self.bulkId: Optional[str] = payload.get("bulkId")
        self.numSegments: Optional[int] = deserialize.integer(payload.get("numSegments"))
        self.numMedia: Optional[int] = deserialize.integer(payload.get("numMedia"))
        self.price: Optional[float] = deserialize.decimal(payload.get("price"))
        self.priceUnit: Optional[str] = payload.get("priceUnit")
        self.messageId: Optional[str] = payload.get("messageId")
        self.status: Optional[str] = payload.get("status")
        self.messageType: Optional[str] = payload.get("messageType")
        self.errorCode: Optional[int] = deserialize.integer(payload.get("errorCode"))
        self.errorMessage: Optional[str] = payload.get("errorMessage")
        self.dateCreated: Optional[datetime] = deserialize.iso8601_datetime(payload.get("dateCreated"))
        self.dateSent: Optional[datetime] = deserialize.iso8601_datetime(payload.get("dateSent"))
        self.dateUpdated: Optional[datetime] = deserialize.iso8601_datetime(payload.get("dateUpdated"))

        
        self._context: Optional[MessagingItemContext] = None

    @property
    def _proxy(self) -> "MessagingItemContext":
        """
        Generate an instance context for the instance, the context is capable of
        performing various actions. All instance actions are proxied to the context

        :returns: MessagingItemContext for this MessagingItemInstance
        """
        if self._context is None:
            self._context = MessagingItemContext(self._version,)
        return self._context
    
    
    def delete(self, message_id: str) -> bool:
        """
        Deletes the MessagingItemInstance
        
        :param message_id: The identifier of the message to be updated.

        :returns: True if delete succeeds, False otherwise
        """
        return self._proxy.delete(message_id=message_id, )
    async def delete_async(self, message_id: str) -> bool:
        """
        Asynchronous coroutine that deletes the MessagingItemInstance
        
        :param message_id: The identifier of the message to be updated.

        :returns: True if delete succeeds, False otherwise
        """
        return await self._proxy.delete_async(message_id=message_id, )
    
    
    def fetch(self, message_id: str) -> "MessagingItemInstance":
        """
        Fetch the MessagingItemInstance
        
        :param message_id: The identifier of the message to be updated.

        :returns: The fetched MessagingItemInstance
        """
        return self._proxy.fetch(message_id=message_id, )

    async def fetch_async(self, message_id: str) -> "MessagingItemInstance":
        """
        Asynchronous coroutine to fetch the MessagingItemInstance
        
        :param message_id: The identifier of the message to be updated.

        :returns: The fetched MessagingItemInstance
        """
        return await self._proxy.fetch_async(message_id=message_id, )
    
    
    def unschedule(self, message_id: str) -> "MessagingItemInstance":
        """
        Unschedule the MessagingItemInstance
        
        :param message_id: The identifier of the message to be unscheduled.

        :returns: The unscheduled MessagingItemInstance
        """
        return self._proxy.unschedule(message_id=message_id, )

    async def unschedule_async(self, message_id: str) -> "MessagingItemInstance":
        """
        Asynchronous coroutine to unschedule the MessagingItemInstance
        
        :param message_id: The identifier of the message to be unscheduled.

        :returns: The unscheduled MessagingItemInstance
        """
        return await self._proxy.unschedule_async(message_id=message_id, )
    
    
    def update(self, message_id: str, body: str) -> "MessagingItemInstance":
        """
        Update the MessagingItemInstance
        
        :param message_id: The identifier of the message to be updated.
        :param body: The text to be newly associated with the message.

        :returns: The updated MessagingItemInstance
        """
        return self._proxy.update(message_id=message_id, body=body, )

    async def update_async(self, message_id: str, body: str) -> "MessagingItemInstance":
        """
        Asynchronous coroutine to update the MessagingItemInstance
        
        :param message_id: The identifier of the message to be updated.
        :param body: The text to be newly associated with the message.

        :returns: The updated MessagingItemInstance
        """
        return await self._proxy.update_async(message_id=message_id, body=body, )
    
    def __repr__(self) -> str:
        """
        Provide a friendly representation

        :returns: Machine friendly representation
        """
        
        return '<Reach.Api.Messaging.MessagingItemInstance>'

    def __str__(self) -> str:
        """
        Provide a str representation

        :returns: str representation
        """
        repr = { 
            'appletId': self.appletId,
            'apiVersion': self.apiVersion,
            'body': self.body,
            'dest': self.dest,
            'src': self.src,
            'bulkId': self.bulkId,
            'numSegments': self.numSegments,
            'numMedia': self.numMedia,
            'price': self.price,
            'priceUnit': self.priceUnit,
            'messageId': self.messageId,
            'status': self.status,
            'messageType': self.messageType,
            'errorCode': self.errorCode,
            'errorMessage': self.errorMessage,
            'dateCreated': self.dateCreated,
            'dateSent': self.dateSent,
            'dateUpdated': self.dateUpdated,
        }
        return serialize.serialize(repr)

class MessagingItemContext(InstanceContext):

    def __init__(self, version: Version):
        """
        Initialize the MessagingItemContext

        :param version: Version that contains the resource
        """
        super().__init__(version)

        
        
        
        self._uri = { 
            'fetch': '/messaging/v1/fetch',
            'update': '/messaging/v1/update',
            'delete': '/messaging/v1/delete',
            'unschedule': '/messaging/v1/unschedule',
        }
        
        
    
    
    def delete(self, message_id: str) -> bool:
        """
        Deletes the MessagingItemInstance

        :param message_id: The identifier of the message to be updated.
        
        :returns: True if delete succeeds, False otherwise
        """
        headers = values.of({'messageId': message_id, })
        
        return self._version.delete(method='DELETE', uri=self._uri['delete'], params=headers)

    async def delete_async(self, message_id: str) -> bool:
        """
        Asynchronous coroutine that deletes the MessagingItemInstance

        :param message_id: The identifier of the message to be updated.
        
        :returns: True if delete succeeds, False otherwise
        """
        headers = values.of({'messageId': message_id, })
        
        return await self._version.delete_async(method='DELETE', uri=self._uri['delete'], params=headers)
    
    
    def fetch(self, message_id: str) -> MessagingItemInstance:
        """
        Fetch the MessagingItemInstance
        
        :param message_id: The identifier of the message to be updated.

        :returns: The fetched MessagingItemInstance
        """
        
        data = values.of({ 
            'messageId': message_id,
        })
        
        payload = self._version.fetch(method='GET', uri=self._uri['fetch'], params=data)

        return MessagingItemInstance(
            self._version,
            payload,
            
        )

    async def fetch_async(self, message_id: str) -> MessagingItemInstance:
        """
        Asynchronous coroutine to fetch the MessagingItemInstance
        
        :param message_id: The identifier of the message to be updated.

        :returns: The fetched MessagingItemInstance
        """
        
        data = values.of({ 
            'messageId': message_id,
        })
        
        payload = await self._version.fetch_async(method='GET', uri=self._uri['fetch'], params=data)

        return MessagingItemInstance(
            self._version,
            payload,
            
        )
    
    
    def unschedule(self, message_id: str) -> MessagingItemInstance:
        """
        Unschedule the MessagingItemInstance
        
        :param message_id: The identifier of the message to be unscheduled.

        :returns: The unscheduled MessagingItemInstance
        """
        data = values.of({ 
            'messageId': message_id,
        })
        

        payload = self._version.unschedule(method='POST', uri=self._uri['unschedule'], data=data,)

        return MessagingItemInstance(
            self._version,
            payload
        )

    async def unschedule_async(self, message_id: str) -> MessagingItemInstance:
        """
        Asynchronous coroutine to unschedule the MessagingItemInstance
        
        :param message_id: The identifier of the message to be unscheduled.

        :returns: The unscheduled MessagingItemInstance
        """
        data = values.of({ 
            'messageId': message_id,
        })
        

        payload = await self._version.unschedule_async(method='POST', uri=self._uri['unschedule'], data=data,)

        return MessagingItemInstance(
            self._version,
            payload
        )
    
    
    def update(self, message_id: str, body: str) -> MessagingItemInstance:
        """
        Update the MessagingItemInstance
        
        :param message_id: The identifier of the message to be updated.
        :param body: The text to be newly associated with the message.

        :returns: The updated MessagingItemInstance
        """
        data = values.of({ 
            'messageId': message_id,
            'body': body,
        })
        

        payload = self._version.update(method='POST', uri=self._uri['update'], data=data,)

        return MessagingItemInstance(
            self._version,
            payload
        )

    async def update_async(self, message_id: str, body: str) -> MessagingItemInstance:
        """
        Asynchronous coroutine to update the MessagingItemInstance
        
        :param message_id: The identifier of the message to be updated.
        :param body: The text to be newly associated with the message.

        :returns: The updated MessagingItemInstance
        """
        data = values.of({ 
            'messageId': message_id,
            'body': body,
        })
        

        payload = await self._version.update_async(method='POST', uri=self._uri['update'], data=data,)

        return MessagingItemInstance(
            self._version,
            payload
        )
    
    
    def __repr__(self) -> str:
        """
        Provide a friendly representation

        :returns: Machine friendly representation
        """
        
        return '<Reach.Api.Messaging.MessagingItemContext>'











class MessagingItemPage(Page):

    def get_instance(self, payload: Dict[str, Any]) -> MessagingItemInstance:
        """
        Build an instance of MessagingItemInstance

        :param payload: Payload response from the API
        """
        return MessagingItemInstance(self._version, payload)

    def __repr__(self) -> str:
        """
        Provide a friendly representation

        :returns: Machine friendly representation
        """
        return "<Reach.Api.Messaging.MessagingItemPage>"







class MessagingItemList(ListResource):

    def __init__(self, version: Version):
        """
        Initialize the MessagingItemList

        :param version: Version that contains the resource
        
        """
        super().__init__(version)

        
        
        self._uri = { 
            'read': '/messaging/v1/list',
            'send': '/messaging/v1/create',
        }
        
        
        
    
    
    
    
    
    def stream(self, 
        dest: Union[str, object] = values.unset,
        src: Union[str, object] = values.unset,
        bulk_identifier: Union[str, object] = values.unset,
        sent_at: Union[datetime, object] = values.unset,
        sent_after: Union[datetime, object] = values.unset,
        sent_before: Union[datetime, object] = values.unset,
        
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> Iterator[MessagingItemInstance]:
        """
        Streams MessagingItemInstance records from the API as a generator stream.
        This operation lazily loads records as efficiently as possible until the limit
        is reached.
        The results are returned as a generator, so this operation is memory efficient.
        
        :param str dest: Retrieve messages sent to only this phone number. The phone number in E.164 format of the message.
        :param str src: Retrieve messages sent from only this phone number, in E.164 format, or alphanumeric sender ID.
        :param str bulk_identifier: Retrieve only messages that are assocaited with this `bulkIdentifier`.
        :param datetime sent_at: Retrieve only messages sent at the specified date. Must be in ISO 8601 format.
        :param datetime sent_after: Retrieve only messages sent after the specified datetime. Must be in ISO 8601 format.
        :param datetime sent_before: Retrieve only messages sent before the specified datetime. Must be in ISO 8601 format.
        :param limit: Upper limit for the number of records to return. stream()
                      guarantees to never return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, stream() will attempt to read the
                          limit with the most efficient page size, i.e. min(limit, 1000)

        :returns: Generator that will yield up to limit results
        """
        limits = self._version.read_limits(limit, page_size)
        page = self.page(
            dest=dest,
            src=src,
            bulk_identifier=bulk_identifier,
            sent_at=sent_at,
            sent_after=sent_after,
            sent_before=sent_before,
            page_size=limits['page_size']
        )

        return self._version.stream(page, limits['limit'])

    async def stream_async(self, 
        dest: Union[str, object] = values.unset,
        src: Union[str, object] = values.unset,
        bulk_identifier: Union[str, object] = values.unset,
        sent_at: Union[datetime, object] = values.unset,
        sent_after: Union[datetime, object] = values.unset,
        sent_before: Union[datetime, object] = values.unset,
        
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> AsyncIterator[MessagingItemInstance]:
        """
        Asynchronously streams MessagingItemInstance records from the API as a generator stream.
        This operation lazily loads records as efficiently as possible until the limit
        is reached.
        The results are returned as a generator, so this operation is memory efficient.
        
        :param str dest: Retrieve messages sent to only this phone number. The phone number in E.164 format of the message.
        :param str src: Retrieve messages sent from only this phone number, in E.164 format, or alphanumeric sender ID.
        :param str bulk_identifier: Retrieve only messages that are assocaited with this `bulkIdentifier`.
        :param datetime sent_at: Retrieve only messages sent at the specified date. Must be in ISO 8601 format.
        :param datetime sent_after: Retrieve only messages sent after the specified datetime. Must be in ISO 8601 format.
        :param datetime sent_before: Retrieve only messages sent before the specified datetime. Must be in ISO 8601 format.
        :param limit: Upper limit for the number of records to return. stream()
                      guarantees to never return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, stream() will attempt to read the
                          limit with the most efficient page size, i.e. min(limit, 1000)

        :returns: Generator that will yield up to limit results
        """
        limits = self._version.read_limits(limit, page_size)
        page = await self.page_async(
            dest=dest,
            src=src,
            bulk_identifier=bulk_identifier,
            sent_at=sent_at,
            sent_after=sent_after,
            sent_before=sent_before,
            page_size=limits['page_size']
        )

        return self._version.stream_async(page, limits['limit'])

    def list(self, 
        dest: Union[str, object] = values.unset,
        src: Union[str, object] = values.unset,
        bulk_identifier: Union[str, object] = values.unset,
        sent_at: Union[datetime, object] = values.unset,
        sent_after: Union[datetime, object] = values.unset,
        sent_before: Union[datetime, object] = values.unset,
        
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> List[MessagingItemInstance]:
        """
        Lists MessagingItemInstance records from the API as a list.
        Unlike stream(), this operation is eager and will load `limit` records into
        memory before returning.
        
        :param str dest: Retrieve messages sent to only this phone number. The phone number in E.164 format of the message.
        :param str src: Retrieve messages sent from only this phone number, in E.164 format, or alphanumeric sender ID.
        :param str bulk_identifier: Retrieve only messages that are assocaited with this `bulkIdentifier`.
        :param datetime sent_at: Retrieve only messages sent at the specified date. Must be in ISO 8601 format.
        :param datetime sent_after: Retrieve only messages sent after the specified datetime. Must be in ISO 8601 format.
        :param datetime sent_before: Retrieve only messages sent before the specified datetime. Must be in ISO 8601 format.
        :param limit: Upper limit for the number of records to return. list() guarantees
                      never to return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, list() will attempt to read the limit
                          with the most efficient page size, i.e. min(limit, 1000)

        :returns: list that will contain up to limit results
        """
        return list(self.stream(
            dest=dest,
            src=src,
            bulk_identifier=bulk_identifier,
            sent_at=sent_at,
            sent_after=sent_after,
            sent_before=sent_before,
            limit=limit,
            page_size=page_size,
        ))

    async def list_async(self, 
        dest: Union[str, object] = values.unset,
        src: Union[str, object] = values.unset,
        bulk_identifier: Union[str, object] = values.unset,
        sent_at: Union[datetime, object] = values.unset,
        sent_after: Union[datetime, object] = values.unset,
        sent_before: Union[datetime, object] = values.unset,
        
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> List[MessagingItemInstance]:
        """
        Asynchronously lists MessagingItemInstance records from the API as a list.
        Unlike stream(), this operation is eager and will load `limit` records into
        memory before returning.
        
        :param str dest: Retrieve messages sent to only this phone number. The phone number in E.164 format of the message.
        :param str src: Retrieve messages sent from only this phone number, in E.164 format, or alphanumeric sender ID.
        :param str bulk_identifier: Retrieve only messages that are assocaited with this `bulkIdentifier`.
        :param datetime sent_at: Retrieve only messages sent at the specified date. Must be in ISO 8601 format.
        :param datetime sent_after: Retrieve only messages sent after the specified datetime. Must be in ISO 8601 format.
        :param datetime sent_before: Retrieve only messages sent before the specified datetime. Must be in ISO 8601 format.
        :param limit: Upper limit for the number of records to return. list() guarantees
                      never to return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, list() will attempt to read the limit
                          with the most efficient page size, i.e. min(limit, 1000)

        :returns: list that will contain up to limit results
        """
        return [record async for record in await self.stream_async(
            dest=dest,
            src=src,
            bulk_identifier=bulk_identifier,
            sent_at=sent_at,
            sent_after=sent_after,
            sent_before=sent_before,
            limit=limit,
            page_size=page_size,
        )]

    def page(self, 
        dest: Union[str, object] = values.unset,
        src: Union[str, object] = values.unset,
        bulk_identifier: Union[str, object] = values.unset,
        sent_at: Union[datetime, object] = values.unset,
        sent_after: Union[datetime, object] = values.unset,
        sent_before: Union[datetime, object] = values.unset,
        
        page_number: Union[int, object] = values.unset,
        page_size: Union[int, object] = values.unset,
    ) -> MessagingItemPage:
        """
        Retrieve a single page of MessagingItemInstance records from the API.
        Request is executed immediately
        
        :param dest: Retrieve messages sent to only this phone number. The phone number in E.164 format of the message.
        :param src: Retrieve messages sent from only this phone number, in E.164 format, or alphanumeric sender ID.
        :param bulk_identifier: Retrieve only messages that are assocaited with this `bulkIdentifier`.
        :param sent_at: Retrieve only messages sent at the specified date. Must be in ISO 8601 format.
        :param sent_after: Retrieve only messages sent after the specified datetime. Must be in ISO 8601 format.
        :param sent_before: Retrieve only messages sent before the specified datetime. Must be in ISO 8601 format.
        :param page_number: Page Number, this value is simply for client state
        :param page_size: Number of records to return, defaults to 20

        :returns: Page of MessagingItemInstance
        """
        data = values.of({ 
            'dest': dest,
            'src': src,
            'bulkIdentifier': bulk_identifier,
            'sentAt': serialize.iso8601_datetime(sent_at),
            'sentAfter': serialize.iso8601_datetime(sent_after),
            'sentBefore': serialize.iso8601_datetime(sent_before),
            'page': page_number,
            'pageSize': page_size,
        })

        baseUrl = self._version.absolute_url(uri=self._uri['read'])
        baseUrl = self._version.url_without_pagination_info(baseUrl, params=data)
        response = self._version.page(method='GET', uri=self._uri['read'], params=data)
        return MessagingItemPage(baseUrl, self._version, response)

    async def page_async(self, 
        dest: Union[str, object] = values.unset,
        src: Union[str, object] = values.unset,
        bulk_identifier: Union[str, object] = values.unset,
        sent_at: Union[datetime, object] = values.unset,
        sent_after: Union[datetime, object] = values.unset,
        sent_before: Union[datetime, object] = values.unset,
        
        page_number: Union[int, object] = values.unset,
        page_size: Union[int, object] = values.unset,
    ) -> MessagingItemPage:
        """
        Asynchronously retrieve a single page of MessagingItemInstance records from the API.
        Request is executed immediately
        
        :param dest: Retrieve messages sent to only this phone number. The phone number in E.164 format of the message.
        :param src: Retrieve messages sent from only this phone number, in E.164 format, or alphanumeric sender ID.
        :param bulk_identifier: Retrieve only messages that are assocaited with this `bulkIdentifier`.
        :param sent_at: Retrieve only messages sent at the specified date. Must be in ISO 8601 format.
        :param sent_after: Retrieve only messages sent after the specified datetime. Must be in ISO 8601 format.
        :param sent_before: Retrieve only messages sent before the specified datetime. Must be in ISO 8601 format.
        :param page_number: Page Number, this value is simply for client state
        :param page_size: Number of records to return, defaults to 20

        :returns: Page of MessagingItemInstance
        """
        data = values.of({ 
            'dest': dest,
            'src': src,
            'bulkIdentifier': bulk_identifier,
            'sentAt': serialize.iso8601_datetime(sent_at),
            'sentAfter': serialize.iso8601_datetime(sent_after),
            'sentBefore': serialize.iso8601_datetime(sent_before),
            'page': page_number,
            'pageSize': page_size,
        })

        baseUrl = self._version.absolute_url(uri=self._uri['read'])
        baseUrl = self._version.url_without_pagination_info(baseUrl, params=data)
        response = await self._version.page_async(method='GET', uri=self._uri['read'], params=data)
        return MessagingItemPage(baseUrl, self._version, response)

    def get_page(self, target_url: str) -> MessagingItemPage:
        """
        Retrieve a specific page of MessagingItemInstance records from the API.
        Request is executed immediately

        :param target_url: API-generated URL for the requested results page

        :returns: Page of MessagingItemInstance
        """
        baseUrl = self._version.url_without_pagination_info(target_url)
        response = self._version.domain.reach.request(
            'GET',
            target_url
        )
        return MessagingItemPage(baseUrl, self._version, response)

    async def get_page_async(self, target_url: str) -> MessagingItemPage:
        """
        Asynchronously retrieve a specific page of MessagingItemInstance records from the API.
        Request is executed immediately

        :param target_url: API-generated URL for the requested results page

        :returns: Page of MessagingItemInstance
        """
        baseUrl = self._version.url_without_pagination_info(target_url)
        response = await self._version.domain.reach.request_async(
            'GET',
            target_url
        )
        return MessagingItemPage(baseUrl, self._version, response)

    
    def send(self, dest: str, src: str, body: str, bulk_identifier: Union[str, object]=values.unset, scheduled_time: Union[datetime, object]=values.unset, status_callback: Union[str, object]=values.unset, max_price: Union[float, object]=values.unset, validity_period: Union[int, object]=values.unset) -> MessagingItemInstance:
        """
        Send the MessagingItemInstance

        :param dest: The destination phone number in E.164 format of the message.
        :param src: The phone number (in E.164 format), or the alphanumeric sender ID that initiated the message.
        :param body: The text of the message to send. It can be up to 1,600 GSM-7 characters in length. That limit varies if your message is not made of only GSM-7 characters. More generally, the message body should not exceed 10 segments.
        :param bulk_identifier: The identifier of the bulk operation this message belongs to.
        :param scheduled_time: The datetime at which the message will be sent. Must be in ISO 8601 format. A message must be scheduled at least 15 min in advance of message send time and cannot be scheduled more than 5 days in advance of the request.
        :param status_callback: The URL that will be called to send status information of your message. If provided, the API POST these message status changes to the URL: `queued`, `failed`, `sent`, `canceled`, `delivered`, or `undelivered`. URLs must contain a valid hostname and underscores are not allowed. 
        :param max_price: The maximum total price in the applet currency that should be paid for the message to be delivered. If the cost exceeds `maxPrice`, the message will fail and a status of `failed` is sent to the status callback. 
        :param validity_period: It represents how long, in seconds, the message can remain in the queue. After this period elapses, the message fails and the status callback is called. After a message has been accepted by a carrier, however, there is no guarantee that the message will not be queued after this period. It is recommended that this value be at least 5 seconds. The maximum allowed value is 14,400 which corresponds to 4 hours. 
        
        :returns: The sent MessagingItemInstance
        """
        data = values.of({ 
            'dest': dest,
            'src': src,
            'body': body,
            'bulkIdentifier': bulk_identifier,
            'scheduledTime': serialize.iso8601_datetime(scheduled_time),
            'statusCallback': status_callback,
            'maxPrice': max_price,
            'validityPeriod': validity_period,
        })
        
        payload = self._version.send(method='POST', uri=self._uri['send'], data=data,)

        return MessagingItemInstance(self._version, payload)

    async def send_async(self, dest: str, src: str, body: str, bulk_identifier: Union[str, object]=values.unset, scheduled_time: Union[datetime, object]=values.unset, status_callback: Union[str, object]=values.unset, max_price: Union[float, object]=values.unset, validity_period: Union[int, object]=values.unset) -> MessagingItemInstance:
        """
        Asynchronously send the MessagingItemInstance

        :param dest: The destination phone number in E.164 format of the message.
        :param src: The phone number (in E.164 format), or the alphanumeric sender ID that initiated the message.
        :param body: The text of the message to send. It can be up to 1,600 GSM-7 characters in length. That limit varies if your message is not made of only GSM-7 characters. More generally, the message body should not exceed 10 segments.
        :param bulk_identifier: The identifier of the bulk operation this message belongs to.
        :param scheduled_time: The datetime at which the message will be sent. Must be in ISO 8601 format. A message must be scheduled at least 15 min in advance of message send time and cannot be scheduled more than 5 days in advance of the request.
        :param status_callback: The URL that will be called to send status information of your message. If provided, the API POST these message status changes to the URL: `queued`, `failed`, `sent`, `canceled`, `delivered`, or `undelivered`. URLs must contain a valid hostname and underscores are not allowed. 
        :param max_price: The maximum total price in the applet currency that should be paid for the message to be delivered. If the cost exceeds `maxPrice`, the message will fail and a status of `failed` is sent to the status callback. 
        :param validity_period: It represents how long, in seconds, the message can remain in the queue. After this period elapses, the message fails and the status callback is called. After a message has been accepted by a carrier, however, there is no guarantee that the message will not be queued after this period. It is recommended that this value be at least 5 seconds. The maximum allowed value is 14,400 which corresponds to 4 hours. 
        
        :returns: The sent MessagingItemInstance
        """
        data = values.of({ 
            'dest': dest,
            'src': src,
            'body': body,
            'bulkIdentifier': bulk_identifier,
            'scheduledTime': serialize.iso8601_datetime(scheduled_time),
            'statusCallback': status_callback,
            'maxPrice': max_price,
            'validityPeriod': validity_period,
        })
        
        payload = await self._version.send_async(method='POST', uri=self._uri['send'], data=data,)

        return MessagingItemInstance(self._version, payload)
    


    def get(self) -> MessagingItemContext:
        """
        Constructs a MessagingItemContext
        
        """
        return MessagingItemContext(self._version)

    def __call__(self) -> MessagingItemContext:
        """
        Constructs a MessagingItemContext
        
        """
        return MessagingItemContext(self._version)

    def __repr__(self) -> str:
        """
        Provide a friendly representation

        :returns: Machine friendly representation
        """
        return '<Reach.Api.Messaging.MessagingItemList>'

